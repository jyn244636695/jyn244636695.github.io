{"meta":{"title":"仰望的知识小站","subtitle":"欢迎来到我的博客","description":"","author":"仰望丶","url":"https://jyn244636695.github.io","root":"/"},"pages":[{"title":"404","date":"2022-06-08T14:53:43.000Z","updated":"2022-06-08T14:55:20.442Z","comments":true,"path":"404/index.html","permalink":"https://jyn244636695.github.io/404/index.html","excerpt":"","text":""},{"title":"about","date":"2022-06-08T14:54:20.000Z","updated":"2022-06-08T14:55:47.203Z","comments":true,"path":"about/index.html","permalink":"https://jyn244636695.github.io/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2022-06-08T14:54:00.000Z","updated":"2022-06-08T14:56:52.415Z","comments":true,"path":"friends/index.html","permalink":"https://jyn244636695.github.io/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-06-08T14:24:23.000Z","updated":"2022-06-08T14:56:05.528Z","comments":true,"path":"categories/index.html","permalink":"https://jyn244636695.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2022-06-08T14:54:12.000Z","updated":"2022-06-08T14:54:12.415Z","comments":true,"path":"contact/index.html","permalink":"https://jyn244636695.github.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-06-08T14:54:33.000Z","updated":"2022-06-08T14:56:22.444Z","comments":true,"path":"tags/index.html","permalink":"https://jyn244636695.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2022-06-08T13:39:54.000Z","updated":"2022-06-09T13:03:02.338Z","comments":true,"path":"2022/06/08/我的第一篇博客/","link":"","permalink":"https://jyn244636695.github.io/2022/06/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"Java基础1.集合1.1 List（有顺序）存储的元素是有序的、可重复的。 1.1.1 ArrayList：数组​ 特点：随机访问效率高，读快写满。线程不安全 ​ 写满：因为需要对数组扩容，扩容的时候会造成写的效率下降。 ​ 扩容机制： ​ 1.先检查当前elementData的长度，若添加后大小超出elementData的长度，则需要扩容 ​ 2.首先将新容量设置为旧容量的1.5倍，如果新容量比可用最小容量小就设置为最小容量；如果大则取极限容量常量和最大整形数的大值。 ​ 3.使用新容量初始化一个新的数组，后复制过去 1.1.2 Vector： 数组​ 1.线程安全，所有public方法都使用了synchronized 关键字 ​ 2.capacityIncrement 标明扩容的增量 1.1.3 LinkedList： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环​ 顺序访问，读慢写快 1.2 Map:使用键值对（key-value）存储，并发环境下推荐使用 ConcurrentHashMap 。 1.2.1HashMap键值对与数组下标的对于关系由key的hashcode值来决定。 hashCode是个int值，存储【0，2^31-1】的哈希值，但实际应用中会集中在某个区域产生hash冲突。 java1.8之前底层为：数组+链表。 ​ 使用松散哈希减少哈希碰撞。 1）Hashmap执行put操作时：比较消耗资源的是遍历链表，扩容数组 2）执行get操作时：比较消耗资源的是遍历链表 java1.8之后为：数组+红黑树+链表 ​ 链表长度大于7之后，会转化树结构。链表查找为O（n），红黑树为O（log2 n） 1.2.2 TreeMap完全使用红黑树实现 1.2.3 HashTable（线程安全） 实现方式被synchronized修饰（但是不适用于高并发场景），且不能存放null为key值。 削弱了并发性，当多个线程竞争容器级的锁时，吞吐量就会降低。 1.2.4 LinkedHashMap1.3 Queue（队列）:1.3.1 PriorityQueue：​ PriorityQueue 是在 JDK1.5 中被引入的, 其与 Queue 的区别会根据队列元素的优先级来调整顺序，优先级高的元素先出。 ​ 内部实现堆排序来将优先级高的对象放在堆顶 这里列举其相关的一些要点： PriorityQueue 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据 PriorityQueue 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。 PriorityQueue 是非线程安全的，且不支持存储 NULL 和 non-comparable 的对象。 PriorityQueue 默认是小顶堆，但可以接收一个 Comparator 作为构造参数，从而来自定义元素优先级的先后。 PriorityQueue 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行。 1.4 Set(唯一):存储的元素不可重复​ 无序性：无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。 ​ 不可重复性：不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。 1.4.1 HashSet​ 底层为HashMap，但是只关注key值，所有的value由一个被static修饰的PRESENT表示。 ​ 1.不会有重复的元素 ​ 2.最多只有一个null ​ 注意： ​ 1.Hashset不是线程安全的 ​ 2.Hashset不维护插入数据的顺序，如果维护插入顺序，可以使用LinkedHashSet ​ 3.不对数据进行排序，排序可以选用TreeSet 1.4.2 LinkedHashSet​ 通过LinkedHashMap实现，线程不安全 1.4.3 TreeSet​ 线程不安全，有序，唯一: 红黑树(自平衡的排序二叉树) ​ 底层用TreeMap来存储数据，把数据有HashSet所有的特性，增加了一个排序的特性，默认使用数据的自然顺序。 ​ 也可以指定Comparator来对数据进行排序。 1.5 并发容器Java 在 1.5 版本之前所谓的线程安全的容器，主要指的就是同步容器。不过同步容器有个最大的问题，那就是性能差，所有方法都用 synchronized 来保证互斥，串行度太高了（例如Hashtable，内部的方法基本都经过synchronized 修饰，存储数据具有强一致特点）。因此 Java 在 1.5 及之后版本提供了性能更高的容器，我们一般称为并发容器。 并发编程大师Doug Lea开发了非常多的并发容器和框架，这些容器大部分在 java.util.concurrent 包中。并发容器数量非常多，主要分为四大类：List、Map、Set 和 Queue。 1.5.1 ConcurrentHashMapHashMap不是线程安全的，在并发情况下可能会造成Race Condition，形成环形链表从而导致死循环（可参考JAVA HASHMAP的死循环一文）。在并发场景下要保证线程安全可以使用 Collections.synchronizedMap() 方法来包装HashMap；Hashtable使用synchronized来保证线程安全，所有访问HashTable的线程都必须竞争同一把锁，在线程竞争激烈的情况下效率非常低下。 基于此，ConcurrentHashMap应运而生。在 ConcurrentHashMap 中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术（JDK1.7）只对所操作的段加锁而不影响客户端对其它段的访问。 关于 ConcurrentHashMap 相关问题，在 Java集合框架-总结 这篇文章中已经提到过。下面梳理一下关于 ConcurrentHashMap 比较重要的问题： ConcurrentHashMap 和 Hashtable 的区别ConcurrentHashMap 底层实现 1.5.2 ConcurrentSkipListMapConcurrentHashMap 是基于 HashMap 实现的，该容器在数据量比较大的时候，链表会转换为红黑树。红黑树在并发情况下，删除和插入过程中有个平衡的过程，会牵涉到大量节点，因此竞争锁资源的代价相对比较高。因此，ConcurrentHashMap 对于小数据量的存取比较有优势。 ConcurrentSkipListMap 是基于基于跳表实现，ConcurrentSkipListMap 的特点是跳表插入、删除、查询操作平均的时间复杂度是 O(log n)，适用于大数据量存取的场景，最常见的是基于跳跃表实现的数据量比较大的缓存。 2 List2.1 CopyOnWriteArrayList简介在很多应用场景中，读操作可能会远远大于写操作。例如，一些网站所保存的用户黑名单，其数据量相对不大。如果用户ID是整数类型，我们就可以用数组来存储。那选择用ArrayList还是Vector呢？ ArrayList 是非线程安全容器，在并发场景下使用很可能会导致线程安全问题。Vector是线程安全的，它也是基于 Synchronized 同步锁实现的线程安全，Synchronized 关键字几乎修饰了所有对外暴露的方法，所以在读远大于写的操作场景中，Vector 将会发生大量锁竞争，从而给系统带来性能开销。 相比之下，CopyOnWriteArrayList 是 java.util.concurrent 包提供的方法，它实现了读操作无锁，写操作则通过操作底层数组的新副本来实现，是一种读写分离（读读共享、写写互斥、读写互斥、写读互斥）的并发策略。 2.2 CopyOnWriteArrayList实现原理CopyOnWriteArrayList 内部维护了一个数组，成员变量 array 就指向这个内部数组，所有的读操作都是基于 array 进行的。 如果在遍历 array 的同时，还有一个写操作，例如增加元素，CopyOnWriteArrayList 是如何处理的呢? CopyOnWriteArrayList 会将 array 复制一份，然后在新复制处理的数组上执行增加元素的操作，执行完之后再将 array 指向这个新的数组。通过下图你可以看到，读写是可以并行的，遍历操作一直都是基于原 array 执行，而写操作则是基于新 array 进行。 从 CopyOnWriteArrayList 的名字就能看出CopyOnWriteArrayList 是满足CopyOnWrite 的 ArrayList，所谓CopyOnWrite 也就是说：在计算机，如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后呢，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉了。 使用 CopyOnWriteArrayList 需要注意的两个方面。一个是应用场景，CopyOnWriteArrayList 仅适用于写操作非常少的场景，而且能够容忍读写的短暂不一致。另一个需要注意的是，CopyOnWriteArrayList 迭代器是只读的，不支持增删改。因为迭代器遍历的仅仅是一个快照，而对快照进行增删改是没有意义的。 3 SetSet 接口的两个实现是 CopyOnWriteArraySet 和 ConcurrentSkipListSet，使用场景可以参考前面讲述的 CopyOnWriteArrayList 和 ConcurrentSkipListMap，它们的原理都是一样的，这里就不再赘述。 2.异常 Throwable Throwable 是 Java 语言中所有错误与异常的超类。Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。 Error（错误） 定义：Error 类及其子类。程序中无法处理的错误，表示运行应用程序中出现了严重的错误。特点：此类错误一般表示代码运行时 JVM 出现问题。通常有 Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！ Exception（异常） 程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。运行时异常 定义：RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。特点：Java 编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。比如NullPointerException空指针异常、ArrayIndexOutBoundException数组下标越界异常、ClassCastException类型转换异常、ArithmeticExecption算术异常。此类异常属于不受检异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。虽然 Java 编译器不会检查运行时异常，但是我们也可以通过 throws 进行声明抛出，也可以通过 try-catch 对它进行捕获处理。如果产生运行时异常，则需要通过修改代码来进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！RuntimeException 异常会由 Java 虚拟机自动抛出并自动捕获（就算我们没写异常捕获语句运行时也会抛出错误！！），此类异常的出现绝大数情况是代码本身有问题应该从逻辑上去解决并改进代码。 编译时异常 定义: Exception 中除 RuntimeException 及其子类之外的异常。特点: Java 编译器会检查它。如果程序中出现此类异常，比如 ClassNotFoundException（没有找到指定的类异常），IOException（IO流异常），要么通过throws进行声明抛出，要么通过trycatch进行捕获处理，否则不能通过编译。在程序中，通常不会自定义该类异常，而是直接使用系 统提供的异常类。该异常我们必须手动在代码里添加捕获语句来处理该异常。 受检异常与非受检异常 Java 的所有异常可以分为受检异常（checked exception）和非受检异常（uncheckedexception）。受检异常 编译器要求必须处理的异常。正确的程序在运行过程中，经常容易出现的、符合预期的异常情况。一旦发生此类异常，就必须采用某种方式进行处理。除 RuntimeException 及其子类外，其他的Exception 异常都属于受检异常。编译器会检查此类异常，也就是说当编译器检查到应用中的某 处可能会此类异常时，将会提示你处理本异常——要么使用try-catch捕获，要么使用方法签名中用 throws 关键字抛出，否则编译不通过。非受检异常 编译器不会进行检查并且不要求必须处理的异常，也就说当程序中出现此类异常时，即使我们没有try-catch捕获它，也没有使用throws抛出该异常，编译也会正常通过。该类异常包括运行时异常（RuntimeException极其子类）和错误（Error）。 3.Java异常关键字try – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。catch – 用于捕获异常。catch用来捕获try语句块中发生的异常。fifinally – fifinally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有fifinally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果fifinally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。throw – 用于抛出异常。throws – 用在方法签名中，用于声明该方法可能抛出的异常。 二、 Java异常处理 声明异常通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。注意 非检查异常（Error、RuntimeException 或它们的子类）不可使用 throws 关键字来声明要抛出的异常。一个方法出现编译时异常，就需要 try-catch&#x2F; throws 处理，否则会导致编译错误。 抛出异常如果你觉得解决不了某些异常问题，且不需要调用者处理，那么你可以抛出异常。throw关键字作用是在方法内部抛出一个 Throwable 类型的异常。任何Java代码都可以通过throw语句抛出异常。 捕获异常程序通常在运行之前不报错，但是运行后可能会出现某些未知的错误，但是还不想直接抛出到上一级，那么就需要通过try…catch…的形式进行异常捕获，之后根据不同的异常情况来进行相应的处理。 如何选择异常类型可以根据下图来选择是捕获异常，声明异常还是抛出异常 常见异常处理方式1.直接抛出异常 通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。 private static void readFile(String filePath) throws IOException &#123; File file &#x3D; new File(filePath); String result; BufferedReader reader &#x3D; new BufferedReader(new FileReader(file)); while((result &#x3D; reader.readLine())!&#x3D;null) &#123; System.out.println(result); &#125; reader.close(); &#125; ​ 2.封装异常再抛出 有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。 private static void readFile(String filePath) throws MyException &#123; try &#123; &#x2F;&#x2F; code &#125; catch (IOException e) &#123; MyException ex &#x3D; new MyException(&quot;read file failed.&quot;); ex.initCause(e); throw ex; &#125; &#125; 捕获异常 在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理 private static void readFile(String filePath) &#123; try &#123; &#x2F;&#x2F; code &#125; catch (FileNotFoundException e) &#123; &#x2F;&#x2F; handle FileNotFoundException &#125; catch (IOException e)&#123; &#x2F;&#x2F; handle IOException &#125; &#125; 同一个 catch 也可以捕获多种类型异常，用 | 隔开 private static void readFile(String filePath) &#123; try &#123; &#x2F;&#x2F; code &#125; catch (FileNotFoundException | UnknownHostException e) &#123; &#x2F;&#x2F; handle FileNotFoundException or UnknownHostException &#125; catch (IOException e)&#123; &#x2F;&#x2F; handle IOException &#125; &#125; 自定义异常 习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用） public class MyException extends Exception &#123; public MyException()&#123; &#125; public MyException(String msg)&#123; super(msg); &#125; &#x2F;&#x2F; ... &#125; try-catch-finally 当方法中发生异常，异常处之后的代码不会再执行，如果之前获取了一些本地资源需要释放，则需要在方法正常结束时和 catch 语句中都调用释放本地资源的代码，显得代码比较繁琐，finally 语句可以解决这个问题。 private static void readFile(String filePath) throws MyException &#123; File file &#x3D; new File(filePath); String result; BufferedReader reader &#x3D; null; try &#123; reader &#x3D; new BufferedReader(new FileReader(file)); while((result &#x3D; reader.readLine())!&#x3D;null) &#123; System.out.println(result); &#125; &#125; catch (IOException e) &#123; System.out.println(&quot;readFile method catch block.&quot;); MyException ex &#x3D; new MyException(&quot;read file failed.&quot;); ex.initCause(e); throw ex; &#125; finally &#123; System.out.println(&quot;readFile method finally block.&quot;); if (null !&#x3D; reader) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 调用该方法时，读取文件时若发生异常，代码会进入 catch 代码块，之后进入 fifinally 代码块；若读取文件时未发生异常，则会跳过 catch 代码块直接进入 fifinally 代码块。所以无论代码中是否发生异常，fifianlly 中的代码都会执行。若 catch 代码块中包含 return 语句，fifinally 中的代码还会执行吗？将以上代码中的 catch 子句修改如下： catch (IOException e) &#123; System.out.println(&quot;readFile method catch block.&quot;); return; &#125; 调用 readFile 方法，观察当 catch 子句中调用 return 语句时，finally 子句是否执行readFile method catch block.readFile method finally block.可见，即使 catch 中包含了 return 语句，fifinally 子句依然会执行。若 fifinally 中也包含 return 语句，fifinally 中的 return 会覆盖前面的 return.try-with-resource 上面例子中，fifinally 中的 close 方法也可能抛出 IOException, 从而覆盖了原始异常。JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 AutoCloseable 接口的类。 private static void tryWithResourceTest(){ try (Scanner scanner &#x3D; new Scanner(new FileInputStream(“c:&#x2F;abc”),”UTF-8”)){ &#x2F;&#x2F; code } catch (IOException e){ &#x2F;&#x2F; handle exception }}try 代码块退出时，会自动调用 scanner.close 方法，和把 scanner.close 方法放在 fifinally 代码块中不同的是，若 scanner.close 抛出异常，则会被抑制，抛出的仍然为原始异常。被抑制的异常会由 addSusppressed 方法添加到原来的异常，如果想要获取被抑制的异常列表，可以调用getSuppressed 方法来获取。","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://jyn244636695.github.io/categories/JAVA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jyn244636695.github.io/tags/Java/"}],"author":"仰望丶"},{"title":"Hello World","slug":"hello-world","date":"2022-06-08T13:37:19.778Z","updated":"2022-06-08T13:37:19.778Z","comments":true,"path":"2022/06/08/hello-world/","link":"","permalink":"https://jyn244636695.github.io/2022/06/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://jyn244636695.github.io/categories/JAVA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jyn244636695.github.io/tags/Java/"}]}